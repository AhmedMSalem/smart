{"name":"Smart","tagline":"","body":"# Smart Package Manager\r\n\r\n## Overview\r\n\r\nThe **Smart Package Manager** project has the ambitious objective of\r\ncreating smart and portable algorithms for solving adequately the\r\nproblem of managing software upgrading and installation. This tool\r\nworks in all major distributions, and will bring notable advantages\r\nover native tools currently in use (APT, APT-RPM, YUM, URPMI, etc).\r\n\r\nNotice that this project is not a magical bridge between every\r\ndistribution in the planet. Instead, this is software offering better\r\npackage management for these distributions when working with their\r\nnative packages. Using multiple packaging systems at the same time (like\r\nrpm and dpkg) is possible but would require packages from those systems\r\nto follow the same packaging guidelines. As this is not the case at the\r\nmoment, mixing package systems is not recommended.\r\n\r\nFrom _The Free On-line Dictionary of Computing_:\r\n\r\n    smart\r\n\r\n        1. <programming> Said of a program that does the {Right Thing}\r\n        in a wide variety of complicated circumstances. (...)\r\n\r\n\r\n## Project Status\r\n\r\nThe development of Smart Package Manager started on May 4th, 2004, and\r\nversion 1.0 was released on Aug 14th, 2008, after extended beta testing.\r\n\r\n## Features\r\n\r\n### Modular\r\n\r\nSmart has been developed with modularity and flexibility in mind. It's\r\ncompletely backend-based, and package-manager-agnostic. Support is\r\ncurrently implemented for **RPM**, **DPKG**, and **Slackware**\r\npackage management systems, and porting it to new systems should be\r\nvery easy.\r\n\r\n### Smart Transactions\r\n\r\nThat's one of the most interesting aspects of Smart Package Manager,\r\nand the one who has motivated calling it smart. Computing\r\ntransactions respecting the relations involved in the package\r\nmanagement world may become an unpleasant task when thousands of\r\npackages and relations are being considered, or even when just\r\na few complex relations turn the most obvious choice into the\r\nunwanted one.\r\n\r\nWhile other applications try to find a possible solution to satisfy\r\nthe relations involved in some user-requested operation, and\r\nsometimes even fail to do so [1], Smart goes beyond it. In the\r\nkernel of Smart Package Manager lives an algorithm that will\r\nnot only find a solution, if one is available, but will find\r\nthe best solution. This is done by quickly weighting every\r\npossible solution with a pluggable policy, which redefines\r\nthe term \"best\" depending on the operation goal (install,\r\nremove, upgrade, etc).\r\n\r\nThis behavior has many interesting consequences. In upgrades,\r\nfor instance, while precedence is given to newer versions,\r\nintermediate versions may get selected if they bring a\r\nbetter global result for the system. Packages may even be\r\nreinstalled, if different packages with the same name-version\r\npair have different relations, and the one not installed\r\nis considered a better option.\r\n\r\nAnother important goal achieved with the transaction algorithm\r\nis that, even though it is able to check and fix relations in\r\nthe whole system, it will work even when there are broken\r\nrelations in installed packages. Only relations related to\r\nthe operation being made are checked for correctness.\r\n\r\n.. [1] Check \"Case Studies\" for real cases where the algorithm\r\n       works better than what is implemented in other applications.\r\n\r\n### Multiple Interfaces\r\n\r\nSmart has multiple native and completely integrated interfaces:\r\n\r\n- Command line interface, with several useful subcommands: update,\r\n  install, reinstall, upgrade, remove, check, fix, download, search,\r\n  and more.\r\n\r\n- Shell interface, with command and argument completion, making it\r\n  easy to perform multiple operations quickly using a local or\r\n  remote terminal.\r\n\r\n- Graphic interface, offering the friendliness of visual\r\n  user interaction.\r\n\r\n- Command line interface with graphic feedback, allowing one to\r\n  integrate the power of command line with graphic environments.\r\n\r\nBesides these interfaces, ksmarttray is also included in the Smart\r\npackage. It notifies users about available updates using a KDE\r\ntray icon.\r\n\r\n### Channels\r\n\r\nChannels are the way Smart becomes aware about external repositories\r\nof information. Many different channel types are supported, depending\r\non the backend and kind of information desired:\r\n\r\n- APT-DEB Repository\r\n- APT-RPM Repository\r\n- DPKG Installed Packages\r\n- Mirror Information\r\n- Red Carpet Channel\r\n- RPM Directory\r\n- RPM Header List\r\n- RPM MetaData (YUM)\r\n- RPM Installed Packages\r\n- Slackware Repository\r\n- Slackware Installed Packages\r\n- URPMI Repository\r\n\r\n### Priority Handling\r\n\r\nPriorities are a powerful way to easily handle integration\r\nof multiple channels and explicit user setups regarding\r\npreferred package versions.\r\n\r\nBasically, packages with higher priorities are considered a\r\nbetter option to be installed in the system, even when package\r\nversions state otherwise. Priorities may be individually\r\nassigned to all packages in given channels, to all packages\r\nwith given names, and to packages with given names inside\r\ngiven channels.\r\n\r\nWith custom priority setups, it becomes possible to avoid\r\nunwanted upgrades, force downgrades, select packages in given\r\nchannels as preferential, and other kinds of interesting setups.\r\n\r\n### Autobalancing Mirror System\r\n\r\nSmart offers a very flexible mirror support. Mirrors are URLs\r\nthat supposedly provide the same contents as are available in\r\nother URLs, named origins. There is no internal restriction on\r\nthe kind of information which is mirrored. Once an origin URL\r\nis provided, and one or more mirror URLs are provided, these\r\nmirrors will be considered for any file which is going to be\r\nfetched from an URL starting with the origin URL.\r\n\r\nMirror precedence is dynamically computed based on the history\r\nof downloads of all mirrors available for a given origin URL\r\n(including the origin site itself). The fastest mirrors and\r\nwith less errors are chosen. When errors occur, the next\r\nmirror in the queue is tried.\r\n\r\nFor instance, if a mirror `http://mirror.url/path/` is provided\r\nfor the origin `ftp://origin.url/other/path/`, and a file in\r\n`ftp://origin.url/other/path/subpath/somefile` is going to be\r\nfetched, the mirror will be considered for being used, and the\r\nURL `http://mirror.url/path/subpath/somefile` will be used if\r\nthe mirror is chosen. Notice that strings are compared and\r\nreplaced without any pre-processing, so that it's possible to\r\nuse different schemes (ftp, http, etc) in mirror entries, and\r\neven URLs ending in prefixes of directory entries.\r\n\r\n### Downloading Mechanism\r\n\r\nSmart has a fast parallel downloading mechanism, allowing multiple\r\nconnections to be used for one or more sites. The mechanism\r\nsupports:\r\n\r\n- Resuming\r\n- Timestamp checking\r\n- Parallel uncompression\r\n- Autodetection of FTP user limit\r\n- Cached file validation\r\n\r\nand more.\r\n\r\nAt the moment, the following schemes are nativelly supported:\r\n\r\n- file\r\n- ftp\r\n- http\r\n- https\r\n- scp\r\n\r\nAdditionally, the following schemes are supported when pycurl is\r\navailable:\r\n\r\n- ftps\r\n- telnet\r\n- dict\r\n- ldap\r\n\r\n### Removable Media Support\r\n\r\nSmart Package Manager implements builtin support for removable media\r\n(CDROMs, DVDs, etc) in most of the supported channel types. The\r\nfollowing features are currently implemented:\r\n\r\n- Mountpoint autodetection\r\n- Support for multiple simultaneous media drives\r\n- Medias may be inserted in any order\r\n- Installed system is guaranteed to maintain correct relations\r\n  between media changes\r\n- Remote removable media support using any of the supported schemes\r\n  (ftp, http, scp, etc)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}