
Commands
--------

- Introduce a mixed-mode command, allowing to install/remove/upgrade.

Downloading and committing
--------------------------

- Partial installer may copy to the fixed disk only these entries
  for which there are missing pre-requires.

Removable repositories
----------------------

- Ask channel to check if repository is available somewhere.
- Remove packages for unavailable media and ask to replace
  it when the current transaction has been committed.
- Removable repositories may be remote as well.
- Use localmedia:// for repositories which may be stored on any
  local media (not *one* path like /mnt/cdrom).
- Use a file in the removable media in a standard place
  to inform the repository type/position/name/etc.
- Implement autodetection of channels by introducing an
  autodetect() function in the channel info file.
- Implement plugins which detect different kinds of
  localmedia (autofs, fstab, supermount, etc), with different
  notions of mounting/unmounting/etc.

Mirror system
-------------

- Store history of downloads (bytes, download time, errors)
- History queue is shared by all servers, and has a limited lenght
- Compute penality based on stored history (penality >= 0)
- All servers start with penality = 0
- Use servers with the lowest penality

Priority system
---------------

- Packages and channels have priorities
- Both may be overriden by user configuration
- The final package priority is obtained by taking the user
  priority for the package, if given, or by taking the highest
  channel priority for the given package and summing with the
  package priority.
- Upgrades happen always to a package with the same or a higher
  priority.
- Downgrades may happen if packages with higher priorities are
  found somewhere.
- Priority is used to compute the best choice when multiple options
  are available to satisfy a dependency.

Repositories
------------

- Implement an "auto-repository", which downloads the needed info and
  uses that info to load one or more repositories (mirrors?).

Random
------

- Implement ISO downloading system.

RPM coloring
------------

<jbj> color of a package is union of file colors within.
<jbj> color of a dependency is union of file colors that have the dependency.
<jbj> color of a transaction is union of package colors.
<jbj> %_transaction_color is affinity mask.
<jbj> technically color=1 upgrades color=1, color=2 upgrades color=2. different
      arch is incidental.
<jbj> and color for file maps eaxctly to elf32/elf64 magic in file.
<jbj> dependency color is computed, not stored. there are arrays to attch
      variable number of dependencies to files, gory but straightforward.
<jbj> so starting pt and count saved for each file, depends dict contains 'P'
      or 'R' in 0xff000000 iirc, to determine whether index is into
      provides/requires, 0x00ffffff is index into {N,EVR,F} tag arrays.
<jbj> disjoint dependency graphs, each color is it's own graph, not too scary.
<jbj> the far more important issue is that files, not packages, have
      dependencies attached. that means a ppkg starts to become a lightweight
      container manifest rather than current heavyweight blob.
<jbj> btw, all the arrays are now sorted too, so bsearch becomes possible.
<jbj> hash still better, but rpm always been addicted to bsearch for uglix
      portability hysteria ;-)
<jbj> many-to-one is impossible map. one-to-many through filelist, see rpm -q
      --file{require,provide} 
<jbj> --filerequires displays only DEPENDSDICT(X,N) iff
      value & 0xff000000 == 'R'
<jbj> filedependsN is the number of deps starting at filedpendsX indexed
      through dependsdict that are attached to a file.

Package list sorting
--------------------

<jbj> niemeyer: just the voices in my head. ther is 1 degree of freedom for
tsort. FIFO/LIFO are perfectly ok, but the goal of ordering in an install is to
create as many leaf nodes as soon as possible, number of immediate descendants
in sub-tree is/was easy weight (because available in Knuth's tsort algorithm).
better weight is number of nodes in sub-tree, not just descendants. --chainsaw
seemed obvious thing to do
<jbj> heh, stare at mutisets, think about permutation groups and cycles.
multiply inherited dependencies (i.e. node has multiple possible "parents") is
then a forbidden permutation on the permutation group.

Debian repository
-----------------

Fix of the "whois"-package to work with the new registrar of the .org-domains
(Added 2003-01-31, last checked 2004-04-16) (Download as text) - maintained by
dreamind at dreamind dot de 
Packages: whois
Architectures: i386
deb http://www.dreamind.de/debian/ woody-fixes main 
deb-src http://www.dreamind.de/debian/ woody-fixes main
      
Files:

http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/Packages.gz
http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/Packages
http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/whois_4.5.25-1_i386.deb

Slackware repository
--------------------

slackpkg: http://slackpkg.sourceforge.net/
swaret: http://www.swaret.org/
slapt-get: http://software.jaos.org/

http://www.linuxtux.org/~juhl/slackpacks/

ftp://ftp.nluug.nl/pub/os/Linux/distr/slackware/slackware-current/
ftp://ftp.slackware.com/pub/slackware/slackware-current/

Mandrake repository
-------------------

ftp://ftp.planetmirror.com/pub/plf/mandrake/cooker

Red Carpet repository
---------------------

http://open-carpet.org/
ftp://ftp.ximian.com/pub/
http://rpms.subpop.net/channels.xml.gz

Examples of cases where the upgrading algorithm is better
---------------------------------------------------------

- Package A requires a dependency provided by B-1.0. B-1.0
  is then upgraded to B-2.0, but the dependency needed by A
  is moved to package C. When an upgrade is done, will
  package B-1.0 be upgraded to B-2.0 and C be installed,
  or will A be removed?
  (http://bugzilla.atrpms.net/show_bug.cgi?id=160)

- Package A requires an implicit dependency, which is provided
  by package B, C and D. OTOH, package A has an explicit
  dependency on package C. Will package B and D be selected
  for installation, even though the dependency is satisfied
  by C, which must necessarily be installed?

- Package A is obsoleted by B and C, and they don't conflict.
  Will package B and C be selected for installation?

vim:ts=4:sw=4:et
