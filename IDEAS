
Commands
--------

- Introduce a mixed-mode command, allowing to install/remove/upgrade.

Downloading and committing
--------------------------

- Partial installer may copy to the fixed disk only these entries
  for which there are missing pre-requires.
- Removable repositories are normal repositories with special media
  ID, and a mark saying where the removable media mounting point
  starts.

Removable repositories
----------------------

- Use a file in the removable media in a standard place
  to inform the repository type/position.
- Ask channel to check if repository is available somewhere.
- Remove packages for unavailable media and ask to replace
  it when the current transaction has been committed.
- Removable repositories may be remote as well (?)

Mirror system
-------------

- Store history of downloads (bytes, download time, errors)
- History queue is shared by all servers, and has a limited lenght
- Compute penality based on stored history (penality >= 0)
- All servers start with penality = 0
- Use servers with the lowest penality

Priority system
---------------

- Packages and channels have priorities
- Both may be overriden by user configuration
- The final package priority is obtained by taking the user
  priority for the package, if given, or by taking the highest
  channel priority for the given package and summing with the
  package priority.
- Upgrades happen always to a package with the same or a higher
  priority.
- Downgrades may happen if packages with a higher priority are
  found somewhere.
- Priority is used to compute the best choice when multiple options
  are available to satisfy a dependency.

Removable media handling
------------------------

- Use the concept of removable channels.
- A channel may be queried if it is removable and if it is available.

Repositories
------------

- Implement an "auto-repository", which downloads the needed info and
  uses that info to load one or more repositories (mirrors?).

Random
------

- Implement ISO downloading system.

RPM coloring
------------

<jbj> color of a package is union of file colors within.
<jbj> color of a dependency is union of file colors that have the dependency.
<jbj> color of a transaction is union of package colors.
<jbj> %_transaction_color is affinity mask.
<jbj> technically color=1 upgrades color=1, color=2 upgrades color=2. different
      arch is incidental.
<jbj> and color for file maps eaxctly to elf32/elf64 magic in file.
<jbj> dependency color is computed, not stored. there are arrays to attch
      variable number of dependencies to files, gory but straightforward.
<jbj> so starting pt and count saved for each file, depends dict contains 'P'
      or 'R' in 0xff000000 iirc, to determine whether index is into
      provides/requires, 0x00ffffff is index into {N,EVR,F} tag arrays.
<jbj> disjoint dependency graphs, each color is it's own graph, not too scary.
<jbj> the far more important issue is that files, not packages, have
      dependencies attached. that means a ppkg starts to become a lightweight
      container manifest rather than current heavyweight blob.
<jbj> btw, all the arrays are now sorted too, so bsearch becomes possible.
<jbj> hash still better, but rpm always been addicted to bsearch for uglix
      portability hysteria ;-)
<jbj> many-to-one is impossible map. one-to-many through filelist, see rpm -q
      --file{require,provide} 
<jbj> --filerequires displays only DEPENDSDICT(X,N) iff
      value & 0xff000000 == 'R'
<jbj> filedependsN is the number of deps starting at filedpendsX indexed
      through dependsdict that are attached to a file.

Package list sorting
--------------------

<jbj> niemeyer: just the voices in my head. ther is 1 degree of freedom for
tsort. FIFO/LIFO are perfectly ok, but the goal of ordering in an install is to
create as many leaf nodes as soon as possible, number of immediate descendants
in sub-tree is/was easy weight (because available in Knuth's tsort algorithm).
better weight is number of nodes in sub-tree, not just descendants. --chainsaw
seemed obvious thing to do
<jbj> heh, stare at mutisets, think about permutation groups and cycles.
multiply inherited dependencies (i.e. node has multiple possible "parents") is
then a forbidden permutation on the permutation group.

Debian repository
-----------------

Fix of the "whois"-package to work with the new registrar of the .org-domains
(Added 2003-01-31, last checked 2004-04-16) (Download as text) - maintained by
dreamind at dreamind dot de 
Packages: whois
Architectures: i386
deb http://www.dreamind.de/debian/ woody-fixes main 
deb-src http://www.dreamind.de/debian/ woody-fixes main
      
Files:

http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/Packages.gz
http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/Packages
http://www.dreamind.de/debian/dists/woody-fixes/main/binary-i386/whois_4.5.25-1_i386.deb

Slackware repository
--------------------

slackpkg: http://slackpkg.sourceforge.net/
swaret: http://www.swaret.org/
slapt-get: http://software.jaos.org/

http://www.linuxtux.org/~juhl/slackpacks/

ftp://ftp.nluug.nl/pub/os/Linux/distr/slackware/slackware-current/
ftp://ftp.slackware.com/pub/slackware/slackware-current/

Mandrake repository
-------------------

ftp://ftp.planetmirror.com/pub/plf/mandrake/cooker

Red Carpet repository
---------------------

http://open-carpet.org/
ftp://ftp.ximian.com/pub/
http://rpms.subpop.net/channels.xml.gz

Examples of cases where the upgrading algorithm is better
---------------------------------------------------------

http://bugzilla.atrpms.net/show_bug.cgi?id=160

vim:ts=4:sw=4:et
